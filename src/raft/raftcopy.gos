package raft

//
// this is an outline of the API that raft must expose to
// the service (or tester). see comments below for
// each of these functions for more details.
//
// rf = Make(...)
//   create a new Raft server.
// rf.Start(command interface{}) (index, term, isleader)
//   start agreement on a new log entry
// rf.GetState() (term, isLeader)
//   ask a Raft for its current term, and whether it thinks it is leader
// ApplyMsg
//   each time a new entry is committed to the log, each Raft peer
//   should send an ApplyMsg to the service (or tester)
//   in the same server.
//

import (
	"math"
	"math/rand"
	"sync"
	"sync/atomic"
	"time"

	"6.824-golabs-2020/labrpc"
)

// import "bytes"
// import "6.824-golabs-2020/labgob"

// as each Raft peer becomes aware that successive log entries are
// committed, the peer should send an ApplyMsg to the service (or
// tester) on the same server, via the applyCh passed to Make(). set
// CommandValid to true to indicate that the ApplyMsg contains a newly
// committed log entry.
//
// in Lab 3 you'll want to send other kinds of messages (e.g.,
// snapshots) on the applyCh; at that point you can add fields to
// ApplyMsg, but set CommandValid to false for these other uses.
type Status int

// VoteState 投票的状态 2A
type VoteState int

// AppendEntriesState 追加日志的状态 2A 2B
type AppendEntriesState int

var HeartBeatTimeout = 100 * time.Millisecond

const (
	Normal VoteState = iota //投票过程正常
	Killed                  //Raft节点已终止
	Expire                  //投票(消息\竞选者）过期
	Voted                   //本Term内已经投过票

)

const (
	AppNormal    AppendEntriesState = iota // 追加正常
	AppOutOfDate                           // 追加过时
	AppKilled                              // Raft程序终止
	AppRepeat                              // 追加重复 (2B
	AppCommitted                           // 追加的日志已经提交 (2B
	Mismatch                               // 追加不匹配 (2B

)

type ApplyMsg struct {
	CommandValid bool
	Command      interface{}
	CommandIndex int
}

// A Go object implementing a single Raft peer.
type Raft struct {
	mu        sync.Mutex          // Lock to protect shared access to this peer's state
	peers     []*labrpc.ClientEnd // RPC end points of all peers
	persister *Persister          // Object to hold this peer's persisted state
	me        int                 // this peer's index into peers[]
	dead      int32               // set by Kill()

	// Your data here (2A, 2B, 2C).
	// Look at the paper's Figure 2 for a description of what
	// state a Raft server must maintain.
	status      string     //状态
	term        int        //第几轮投票
	voteFor     int        //为谁投票,-1表示还没投票
	voteCount   int        //获得总票数,初始为0
	logs        []LogEntry //日志条目数组，包含了状态机要执行的指令集，以及收到领导时的任期号
	commitIndex int        // 状态机中已知的被提交的日志条目的索引值(初始化为0，持续递增）
	lastApplied int        // 最后一个被追加到状态机日志的索引值

	// leader拥有的可见变量，用来管理他的follower(leader经常修改的）
	// nextIndex与matchIndex初始化长度应该为len(peers)，Leader对于每个Follower都记录他的nextIndex和matchIndex
	// nextIndex指的是下一个的appendEntries要从哪里开始
	// matchIndex指的是已知的某follower的log与leader的log最大匹配到第几个Index,已经apply
	nextIndex      []int         // 对于每一个server，需要发送给他下一个日志条目的索引值（初始化为leader日志index+1,那么范围就对标len）
	matchIndex     []int         // 对于每一个server，已经复制给该server的最后日志条目下标
	applyChan      chan ApplyMsg // 日志都是存在这里client取（2B）
	overtime       time.Duration //任期倒计时总长
	heartbeatTimer *time.Timer   //心跳倒计时
	electionTimer  *time.Timer   //实现倒计时功能
}
type LogEntry struct {
	Term    int
	Command interface{}
}
type AppendEntriesArgs struct {
	Term         int        // leader的任期
	LeaderId     int        // leader自身的ID
	PrevLogIndex int        // 预计要从哪里追加的index，因此每次要比当前的len(logs)多1 args初始化为：rf.nextIndex[i] - 1
	PrevLogTerm  int        // 追加新的日志的任期号(这边传的应该都是当前leader的任期号 args初始化为：rf.currentTerm
	Entries      []LogEntry // 预计存储的日志（为空时就是心跳连接）
	LeaderCommit int        // leader的commit index指的是最后一个被大多数机器都复制的日志Index
}

type AppendEntriesReply struct {
	Term        int                // leader的term可能是过时的，此时收到的Term用于更新他自己
	Success     bool               //	如果follower与Args中的PreLogIndex/PreLogTerm都匹配才会接过去新的日志（追加），不匹配直接返回false
	AppState    AppendEntriesState // 追加状态
	UpNextIndex int                //下一个更新的点
}

// return currentTerm and whether this server
// believes it is the leader.
func (rf *Raft) GetState() (int, bool) {
	rf.mu.Lock()
	defer rf.mu.Unlock()

	var term int
	var isleader bool
	// Your code here (2A).
	term = rf.term
	isleader = rf.status == "leader"
	return term, isleader
}

// save Raft's persistent state to stable storage,
// where it can later be retrieved after a crash and restart.
// see paper's Figure 2 for a description of what should be persistent.
func (rf *Raft) persist() {
	// Your code here (2C).
	// Example:
	// w := new(bytes.Buffer)
	// e := labgob.NewEncoder(w)
	// e.Encode(rf.xxx)
	// e.Encode(rf.yyy)
	// data := w.Bytes()
	// rf.persister.SaveRaftState(data)
}

// restore previously persisted state.
func (rf *Raft) readPersist(data []byte) {
	if data == nil || len(data) < 1 { // bootstrap without any state?
		return
	}
	// Your code here (2C).
	// Example:
	// r := bytes.NewBuffer(data)
	// d := labgob.NewDecoder(r)
	// var xxx
	// var yyy
	// if d.Decode(&xxx) != nil ||
	//    d.Decode(&yyy) != nil {
	//   error...
	// } else {
	//   rf.xxx = xxx
	//   rf.yyy = yyy
	// }
}

// example RequestVote RPC arguments structure.
// field names must start with capital letters!
type RequestVoteArgs struct {
	// Your data here (2A, 2B).
	Term         int // 候选人的任期
	CandidateId  int // 候选人ID
	LastLogIndex int // 候选人最后的日志索引
	LastLogTerm  int // 候选人最后的日志任期

}

type RequestVoteReply struct {
	// Your data here (2A).
	Term        int  // 投票人的当前任期
	VoteGranted bool // true表示该节点把票投给了候选人
}

// 重置选举倒计时
func (rf *Raft) electionTimerreset() {
	rf.overtime = time.Duration(150+rand.Intn(150)) * time.Millisecond
	// rf.electionTimer = time.NewTimer(rf.overtime)
	rf.electionTimer.Reset(rf.overtime)
}

// 重置心跳倒计时
func (rf *Raft) HeartBeatTimerreset() {
	rf.heartbeatTimer.Reset(HeartBeatTimeout)
}

// 获得master的信息 没问题
func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) {

	rf.mu.Lock()
	defer rf.mu.Unlock()
	// fmt.Printf("args:%+v %d任务 from %d号任务(term:%d)\n", args, rf.me, args.LeaderId, args.Term)
	// Your code here (2A, 2B).
	// fmt.Printf("收到心跳!	%d号任务(term:%d)收到来自%d号任务(term:%d)的心跳!,\n", rf.me, rf.term, args.LeaderId, args.Term)
	//情况1: 收到的rpc的term太旧
	if args.Term < rf.term {
		reply.Term = rf.term
		reply.Success = false
		reply.AppState = AppOutOfDate
		return

	}
	//情况2: 收到的rpc的term 比自己的term大或相等
	if args.Term > rf.term {
		rf.term = args.Term
		rf.status = "follower"
		rf.voteFor = -1
	}
	rf.electionTimerreset()
	// rf.overtime = time.Duration(150+rand.Intn(200)) * time.Millisecond
	// rf.electionTimer.Reset(rf.overtime)
	//情况3: 心跳日志不匹配
	if args.PrevLogIndex >= 0 && (len(rf.logs) <= args.PrevLogIndex || rf.logs[args.PrevLogIndex].Term != args.PrevLogTerm) {

		reply.AppState = Mismatch
		reply.Term = rf.term
		reply.Success = false
		reply.UpNextIndex = rf.commitIndex + 1
		DPrintf("心跳日志不匹配%d任务.term :%d  对面来的长度：%d,现在长度%d,最终长度：%d %+v,%+v\n", rf.me, rf.term, args.LeaderCommit, rf.lastApplied, rf.commitIndex, rf.logs, args.Entries)
		return
	}
	// //情况4: 心跳日志过时
	if args.PrevLogIndex != -1 && rf.commitIndex > args.PrevLogIndex {
		reply.AppState = AppCommitted
		reply.Term = rf.term
		reply.Success = false
		reply.UpNextIndex = rf.commitIndex + 1
		DPrintf("心跳日志过时%d任务.term :%d  对面来的长度：%d,现在长度%d,最终长度：%d %+v,%+v\n", rf.me, rf.term, args.LeaderCommit, rf.lastApplied, rf.commitIndex, rf.logs, args.Entries)
		return
	}

	rf.status = "follower"
	reply.Success = true
	//rf.term = args.Term
	reply.Term = rf.term
	reply.AppState = AppNormal

	// rf.voteCount = 0
	// rf.voteFor = -1
	//
	if args.Entries != nil {
		rf.logs = rf.logs[:args.PrevLogIndex+1]
		rf.logs = append(rf.logs, args.Entries...)

	}
	// fmt.Printf("")
	if args.LeaderCommit > rf.commitIndex {
		// 5.If leaderCommit > commitIndex, set commitIndex = min(leaderCommit, index of last new entry)
		rf.commitIndex = int(math.Min(float64(args.LeaderCommit), float64(len(rf.logs))-1))
	}
	reply.UpNextIndex = rf.commitIndex + 1
	DPrintf("??%d任务.term :%d  对面来的长度：%d,现在长度%d,最终长度：%d %+v,%+v\n", rf.me, rf.term, args.LeaderCommit, rf.lastApplied, rf.commitIndex, rf.logs, args.Entries)
}

// 接受回来的信息
func (rf *Raft) sendAppendEntries(server int, args *AppendEntriesArgs, reply *AppendEntriesReply, appendNums *int, pid int) {

	// fmt.Printf("[	sendAppendEntries func-rf(%v)	] send to rf(%v) %d\n", rf.me, server, reply.AppState)
	DPrintf("开始发送%d任务.term :%d 现在长度%d,最终长度：%d %+v\n", rf.me, rf.term, rf.lastApplied, rf.commitIndex, args.Entries)
	if rf.killed() {
		return
	}
	ok := rf.peers[server].Call("Raft.AppendEntries", args, reply)
	for !ok {

		if rf.killed() {
			return
		}
		ok = rf.peers[server].Call("Raft.AppendEntries", args, reply)

	}
	rf.mu.Lock()
	defer rf.mu.Unlock()
	if args.Term != rf.term {
		return
	}
	// 对reply的返回状态进行分支
	switch reply.AppState {

	// 目标节点crash
	case AppKilled:
		{
			rf.electionTimerreset()
			return
		}

	// 目标节点正常返回
	case AppNormal:
		{
			rf.electionTimerreset()
			// 2A的test目的是让Leader能不能连续任期，所以2A只需要对节点初始化然后返回就好
			// 2B需要判断返回的节点是否超过半数commit，才能将自身commit
			if reply.Success && reply.Term == rf.term && *appendNums <= len(rf.peers)/2 {
				*appendNums++
			}

			if rf.nextIndex[server] > len(rf.logs) {
				return
			}
			rf.matchIndex[server] = args.PrevLogIndex + len(args.Entries)
			rf.nextIndex[server] = reply.UpNextIndex
			if *appendNums > len(rf.peers)/2 {
				// 保证幂等性，不会提交第二次
				*appendNums = 0
				if len(rf.logs) == 0 || rf.logs[len(rf.logs)-1].Term != rf.term {
					// fmt.Printf("rf.logs:失败")
					return
				}
				DPrintf("%d任务,term:%d 已经成功\n", rf.me, rf.term)
				rf.commitIndex = len(rf.logs) - 1
				// for rf.lastApplied < len(rf.logs) {
				// 	rf.lastApplied++
				// 	applyMsg := ApplyMsg{
				// 		CommandValid: true,
				// 		Command:      rf.logs[rf.lastApplied-1].Command,
				// 		CommandIndex: rf.lastApplied,
				// 	}
				// 	rf.applyChan <- applyMsg
				// 	rf.commitIndex = rf.lastApplied
				// }

			}

			return
		}

	case Mismatch:
		rf.electionTimerreset()
		rf.nextIndex[server] = reply.UpNextIndex

	case AppOutOfDate:
		// 该节点变成追随者,并重置rf状态
		rf.status = "follower"
		rf.voteFor = -1
		rf.voteCount = 0
		rf.term = reply.Term
	case AppCommitted:
		rf.electionTimerreset()
		rf.nextIndex[server] = reply.UpNextIndex
	}

	return
}

// example RequestVote RPC handler.
// 投票给别人 没问题
func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) {
	// Your code here (2A, 2B).
	rf.mu.Lock()
	defer rf.mu.Unlock()

	//默认不同意投票
	reply.VoteGranted = false
	reply.Term = rf.term

	//情况1: 请求投票的raft的term太小,不给投票
	if args.Term < rf.term {
		// reply.Term = rf.term
		// fmt.Printf("投票太小!	%d号任务(term:%d)收到来自%d号任务(term:%d)\n", rf.me, rf.term, args.CandidateId, args.Term)
		return
	}

	//情况2: 请求投票的raft的term大 将自己的term更新,如果是自己是candidate状态,转为follower
	if args.Term > rf.term {
		rf.term = args.Term
		// fmt.Printf("%d的任务,term:%d,转为follower\n", rf.me, rf.term)
		//这里本来有投票的代码实现,放在了下面的情况3一起处理
		rf.voteFor = -1
		rf.voteCount = 0
		reply.Term = rf.term
		rf.status = "follower"
		// rf.overtime = time.Duration(150+rand.Intn(200)) * time.Millisecond
		// rf.electionTimer.Reset(rf.overtime)
		rf.electionTimerreset()
		// return
	}
	currentLogIndex := len(rf.logs) - 1
	// 如果currentLogIndex下标不是-1就把term赋值过来
	currentLogTerm := rf.logs[currentLogIndex].Term

	//情况3: 请求投票的raft的term和自己相等情况下,如果rf.voteFor == -1,则投票
	if rf.voteFor == -1 || rf.voteFor == args.CandidateId {
		if args.LastLogTerm > currentLogTerm ||
			(args.LastLogIndex >= currentLogIndex && args.LastLogTerm == currentLogTerm) {
			rf.voteFor = args.CandidateId
			rf.term = args.Term
			reply.VoteGranted = true
			// fmt.Printf("投票成功!	%d号任务(term:%d)收到来自%d号任务(term:%d)\n", rf.me, rf.term, args.CandidateId, args.Term)
			// rf.overtime = time.Duration(150+rand.Intn(200)) * time.Millisecond
			// rf.electionTimer.Reset(rf.overtime) //重新设置投票倒计时
			rf.electionTimerreset()
			return
		}
	}
	// fmt.Printf("args.LastLogTerm = %d\n", args.LastLogTerm)
	// fmt.Printf("currentLogTerm = %d\n", currentLogTerm)
	// fmt.Printf("args.LastLogIndex = %d\n", args.LastLogIndex)
	// fmt.Printf("currentLogIndex = %d\n", currentLogIndex)
	// fmt.Printf("投票失败!	%d号任务(term:%d)收到来自%d号任务(term:%d) \n", rf.me, rf.term, args.CandidateId, args.Term)
	reply.VoteGranted = false
	reply.Term = rf.term
}

// 心跳 没问题
func (rf *Raft) Ticker() {
	for rf.killed() == false {
		select {
		case <-rf.electionTimer.C:
			rf.mu.Lock()
			rf.status = "candidate"
			rf.startelection()
			rf.mu.Unlock()
		case <-rf.heartbeatTimer.C:
			rf.mu.Lock()
			if rf.status == "leader" {
				// rf.heartbeatTimer.Reset(HeartBeatTimeout)
				rf.HeartBeatTimerreset()
				rf.sendHeartBeat()
			}
			rf.mu.Unlock()
		}
	}
}

// 开始选举 ?
func (rf *Raft) startelection() {
	rf.term++
	rf.voteFor = rf.me
	rf.voteCount = 1
	for i := 0; i < len(rf.peers); i++ {
		if i == rf.me {
			continue
		}
		reply := RequestVoteReply{}
		Args := RequestVoteArgs{
			Term:         rf.term,
			CandidateId:  rf.me,
			LastLogIndex: len(rf.logs) - 1, //最后一个日志的索引 包含未提交的
			LastLogTerm:  rf.logs[len(rf.logs)-1].Term,
		}

		// fmt.Printf("发起投票! 	第%d号任务(term:%d)向第%d号任务发起投票\n", rf.me, rf.term, i)
		//以线程的方式发起投票,前面参考文献里面关于锁那个部分提到了
		go rf.sendRequestVote(i, &Args, &reply)
	}
}

// 发送新心跳 没问题
func (rf *Raft) sendHeartBeat() {
	appendNums := 1
	// rf.heartbeatTimer.Reset(HeartBeatTimeout)
	for j, _ := range rf.peers {
		if j == rf.me {
			continue
		}
		p := 0
		appendEntriesArgs := AppendEntriesArgs{
			Term:         rf.term,
			LeaderId:     rf.me,
			PrevLogIndex: 0,
			PrevLogTerm:  0,
			Entries:      nil,
			LeaderCommit: rf.commitIndex,
		}
		//一开始初始化为rf.nextIndex[i] = len(rf.logs) + 1，然后发送的是空的日志
		// if rf.nextIndex[j] == len(rf.logs)+1 {
		// 	fmt.Printf("rf.nextIndex[j]:%d, len(rf.logs):%d\n", rf.nextIndex[j], len(rf.logs))
		// }
		appendEntriesArgs.Entries = rf.logs[rf.nextIndex[j]:]

		// 代表已经不是初始值0
		if rf.nextIndex[j] > 0 {
			appendEntriesArgs.PrevLogIndex = rf.nextIndex[j] - 1
		}

		if appendEntriesArgs.PrevLogIndex > 0 {
			//fmt.Println("len(rf.log):", len(rf.logs), "PrevLogIndex):", args.PrevLogIndex, "rf.nextIndex[i]", rf.nextIndex[i])
			appendEntriesArgs.PrevLogTerm = rf.logs[appendEntriesArgs.PrevLogIndex].Term
		}
		reply := AppendEntriesReply{}
		go rf.sendAppendEntries(j, &appendEntriesArgs, &reply, &appendNums, p)
		p++
	}
}

// 请求给我投票 没问题
func (rf *Raft) sendRequestVote(server int, args *RequestVoteArgs, reply *RequestVoteReply) bool {

	// fmt.Printf("%d任务,%d term,开始选举\n", rf.me, rf.term)
	ok := rf.peers[server].Call("Raft.RequestVote", args, reply)
	for ok == false {
		ok = rf.peers[server].Call("Raft.RequestVote", args, reply)
	}
	rf.mu.Lock()
	defer rf.mu.Unlock()

	if args.Term != rf.term { // 网络堵塞导致未及时收到过时信息
		return false
	}
	//发送的term比自己的term大 说明自己已经过时
	if reply.Term > rf.term {
		rf.term = reply.Term
		rf.status = "follower"
		rf.voteCount = 0
		rf.voteFor = -1
		return false
	}
	rf.electionTimerreset()
	// rf.timer.Reset(time.Duration(150+rand.Intn(200)) * time.Millisecond)
	if reply.VoteGranted == true {
		// fmt.Printf("	同意投票! 	%d号任务(term:%d) 同意给	%d号任务(term:%d) 投票\n", server, rf.term, rf.me, reply.Term)
		if rf.voteCount <= (len(rf.peers))/2 {
			rf.voteCount++
		}
		if rf.voteCount > (len(rf.peers))/2 {
			if rf.status == "follower" {
				return ok
			}
			if rf.status == "leader" {
				return ok
			}
			DPrintf("新leader!!     第%d号任务已经有选票%d,已经进入leader状态\n", rf.me, rf.voteCount)
			rf.status = "leader"
			// rf.heartbeatTimer.Reset(HeartBeatTimeout)
			rf.HeartBeatTimerreset()
			rf.nextIndex = make([]int, len(rf.peers))
			for i, _ := range rf.nextIndex {
				rf.nextIndex[i] = len(rf.logs)
				rf.matchIndex[i] = 0
			}
		}
	}
	return ok
}

const CommitCheckTimeInterval = time.Duration(100) * time.Millisecond // 检查是否可以commit的间隔
func (rf *Raft) CommitChecker() {
	// 检查是否有新的commit
	for !rf.killed() {
		rf.mu.Lock()
		for rf.commitIndex > rf.lastApplied {
			rf.lastApplied += 1
			msg := &ApplyMsg{
				CommandValid: true,
				Command:      rf.logs[rf.lastApplied].Command,
				CommandIndex: rf.lastApplied,
			}
			rf.applyChan <- *msg
			// fmt.Printf("%d任务.term :%d 现在长度%d,最终长度：%d %+v\n", rf.me, rf.term, rf.lastApplied, rf.commitIndex, msg)
			// DPrintf("server %v 准备将命令 %v(索引为 %v ) 应用到状态机\n", rf.me, msg.Command, msg.CommandIndex)
		}
		rf.mu.Unlock()
		time.Sleep(CommitCheckTimeInterval)
	}
}

// 开始没问题
func (rf *Raft) Start(command interface{}) (int, int, bool) {
	index := -1
	term := -1
	isLeader := true
	if rf.killed() {
		return index, term, false
	}
	// Your code here (2B).
	rf.mu.Lock()
	defer rf.mu.Unlock()

	// 如果不是leader，直接返回
	if rf.status != "leader" {
		return index, term, false
	}
	appendLog := LogEntry{Term: rf.term, Command: command}
	rf.logs = append(rf.logs, appendLog)
	index = len(rf.logs) - 1
	term = rf.term
	// fmt.Printf("!!%d任务.term :%d 现在长度%d,最终长度：%d %+v\n", rf.me, rf.term, rf.lastApplied, rf.commitIndex, rf.logs)

	return index, term, isLeader
}

func (rf *Raft) Kill() {
	atomic.StoreInt32(&rf.dead, 1)
	// Your code here, if desired.
}

func (rf *Raft) killed() bool {
	z := atomic.LoadInt32(&rf.dead)
	return z == 1
}

// 没问题
func Make(peers []*labrpc.ClientEnd, me int,
	persister *Persister, applyCh chan ApplyMsg) *Raft {
	rf := &Raft{}
	rf.peers = peers
	rf.persister = persister
	rf.me = me
	rf.logs = make([]LogEntry, 0)
	rf.commitIndex = 0
	rf.lastApplied = 0
	rf.logs = append(rf.logs, LogEntry{Term: 0})
	rf.nextIndex = make([]int, len(peers))
	rf.matchIndex = make([]int, len(peers))
	rf.status = "follower"
	rf.term = 0
	// fmt.Println("start!")
	// Your initialization code here (2A, 2B, 2C).
	rf.voteFor = -1
	rf.applyChan = applyCh
	rf.voteCount = 0
	// initialize from state persisted before a crash
	for i := 0; i < len(rf.nextIndex); i++ {
		rf.nextIndex[i] = 1 // raft中的index是从1开始的
	}
	rf.overtime = time.Duration(150+rand.Intn(150)) * time.Millisecond
	rf.electionTimer = time.NewTimer(rf.overtime)
	rf.heartbeatTimer = time.NewTimer(HeartBeatTimeout)
	rf.readPersist(persister.ReadRaftState())
	go rf.Ticker()
	go rf.CommitChecker()
	return rf
}
